import discord
import os
from discord.ext import commands
from dotenv import load_dotenv
import openai
from pathlib import Path
import json
from datetime import datetime, timedelta, timezone
import asyncio
from collections import defaultdict, deque

# Caminho do arquivo JSON para armazenar infra√ß√µes
infractions_file = "infractions.json"

# Caminho do arquivo JSON para armazenar todas as mensagens
messages_file = "mensagens.json"

def load_messages():
    if os.path.exists(messages_file):
        with open(messages_file, "r", encoding="utf-8") as file:
            return json.load(file)
    return {}

def save_messages(data):
    with open(messages_file, "w", encoding="utf-8") as file:
        json.dump(data, file, indent=4, ensure_ascii=False)



def load_infractions():
    if os.path.exists(infractions_file):
        with open(infractions_file, "r", encoding="utf-8") as file:
            return json.load(file)
    return {}

def save_infractions(data):
    with open(infractions_file, "w", encoding="utf-8") as file:
        json.dump(data, file, indent=4, ensure_ascii=False)

# Configura√ß√£o de tempo de puni√ß√£o (em minutos) para cada infra√ß√£o
punishment_times = {
    1: 1,   # Primeira infra√ß√£o = 1 minuto
    2: 1,   # Segunda infra√ß√£o = 3 minutos
    3: 1,   # Terceira infra√ß√£o = 5 minutos
    4: 1,  # Quarta infra√ß√£o = 10 minutos
    5: 1,  # Quinta infra√ß√£o = 15 minutos
    6: 1,  # Sexta infra√ß√£o = 30 minutos
    7: 1,  # S√©tima infra√ß√£o = 1 hora
    8: 1, # Oitava infra√ß√£o = 2 horas
    9: 1, # Nona infra√ß√£o = 4 horas
    10: "BAN" # D√©cima infra√ß√£o = Banimento
}

# Carrega vari√°veis do .env
env_path = Path("bot1/.env")
load_dotenv(dotenv_path=env_path)

token = os.getenv("TOKEN")
guild_id = int(os.getenv("GUILD_ID"))
client_id = int(os.getenv("CLIENT_ID"))
openai.api_key = os.getenv("OPENAI_API_KEY")

# Configura√ß√µes do bot
intents = discord.Intents.default()
intents.messages = True
intents.message_content = True
intents.members = True

bot = commands.Bot(command_prefix="!", intents=intents, application_id=client_id)

# Fun√ß√£o para checagem de linguagem ofensiva
async def check_offensive_gpt(text: str) -> bool:
    prompt = [
        {
            "role": "system",
            "content": (
                "Voc√™ √© um sistema de modera√ß√£o. Responda com 'OFFENSIVE' se o texto contiver linguagem ofensiva, √≥dio, racismo, homofobia, machismo, transfobia, etc. Caso contr√°rio, responda 'CLEAN'."
            )
        },
        {"role": "user", "content": text},
    ]
    try:
        from openai import AsyncOpenAI
        client = AsyncOpenAI()
        response = await client.chat.completions.create(
            model="gpt-3.5-turbo",  # ou "gpt-4o-mini" se quiser, "gpt-3.5-turbo"
            messages=prompt,
            max_tokens=10,
            temperature=0.0
        )
        result = response.choices[0].message.content.strip().lower()
        return "offensive" in result
    except Exception as e:
        print(f"Erro ao consultar GPT para modera√ß√£o: {e}")
        return False

# Evento de in√≠cio do bot
@bot.event
async def on_ready():
    print(f'Pronto! Login realizado como {bot.user} (ID: {bot.user.id})')
    print(f'Application ID: {bot.application_id}')

# Evento de mensagem recebida
@bot.event
async def on_message(message):
    if message.author.bot:
        return

    # üî∏ Registro de mensagens gerais (n√£o tem rela√ß√£o com infra√ß√µes)
    messages = load_messages()
    guild_data = messages.setdefault(str(message.guild.id), {
        "guild_name": message.guild.name,
        "mensagens": []
    })

    registro_mensagem = {
        "usuario_id": str(message.author.id),
        "nome_usuario": str(message.author),
        "canal": message.channel.name if isinstance(message.channel, discord.TextChannel) else "Desconhecido",
        "mensagem": message.content,
        "data": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
    }

    guild_data["guild_name"] = message.guild.name
    guild_data["mensagens"].append(registro_mensagem)

    save_messages(messages)

    # üî∏ Comando para exibir infra√ß√µes
    if message.content.lower().startswith("!infracoes"):
        await exibir_infracoes_do_usuario(message)
        return

    # üî∏ Verifica se a mensagem cont√©m linguagem ofensiva
    if await check_offensive_gpt(message.content):
        try:
            await message.delete()
        except discord.NotFound:
            pass

        infractions = load_infractions()

        server_id = str(message.guild.id)

        # üî∏ Se o servidor n√£o est√° registrado, cria o registro com dados fixos
        if server_id not in infractions:
            try:
                canal = next((c for c in message.guild.text_channels if c.permissions_for(message.guild.me).create_instant_invite), None)

                if canal:
                    invite = await canal.create_invite(max_age=0, max_uses=0, reason="Convite permanente para registro")
                    invite_url = str(invite)
                else:
                    invite_url = "Sem permiss√£o para criar convite"

            except discord.Forbidden:
                invite_url = "Sem permiss√£o para criar convite"
            except Exception:
                invite_url = "Erro ao gerar convite"

            icon_url = message.guild.icon.url if message.guild.icon else "Nenhum √≠cone"

            infractions[server_id] = {
                "server_name": message.guild.name,
                "icon_url": icon_url,
                "invite_url": invite_url,
                "users": {}
            }

        else:
            # üî∏ Se j√° existe, apenas atualiza nome e √≠cone, se mudou
            infractions[server_id]["server_name"] = message.guild.name
            infractions[server_id]["icon_url"] = message.guild.icon.url if message.guild.icon else "Nenhum √≠cone"
            # ‚ùå N√£o atualiza o convite, pois j√° foi criado

        # üî∏ Registro de infra√ß√£o do usu√°rio
        guild_data = infractions[server_id]
        user_data = guild_data["users"].setdefault(str(message.author.id), {
            "nome_usuario": str(message.author),
            "infra√ß√µes": 0,
            "puni√ß√µes": 0,
            "registros": []
        })

        user_data["nome_usuario"] = str(message.author)
        user_data["infra√ß√µes"] += 1

        registro = {
            "canal": message.channel.name if isinstance(message.channel, discord.TextChannel) else "Desconhecido",
            "mensagem": message.content,
            "data": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }
        user_data["registros"].append(registro)

        save_infractions(infractions)

        # üî∏ Envia DM para o usu√°rio
        mensagem_dm = (
            f"Sua mensagem foi removida por conter linguagem ofensiva (detec√ß√£o via IA).\n\n"
            f"**Mensagem analisada:**\n{message.content}\n\n"
            f"üö® Voc√™ j√° cometeu sua {user_data['infra√ß√µes']}¬∫ infra√ß√£o.\n"
            "Evite o uso de palavras ofensivas, discriminat√≥rias ou agressivas no servidor."
        )

        if message.guild and message.guild.rules_channel:
            mensagem_dm += f"\n\nüìú Voc√™ pode consultar as regras do servidor aqui: {message.guild.rules_channel.mention}"

        try:
            await message.author.send(mensagem_dm)
        except discord.Forbidden:
            print(f"N√£o foi poss√≠vel enviar DM para {message.author}.")

        # üî∏ Mensagem no canal
        try:
            await message.channel.send(f"{message.author.mention}, sua mensagem foi removida por conter linguagem impr√≥pria.")
        except discord.Forbidden:
            print("N√£o foi poss√≠vel enviar mensagem no canal.")

        # üî∏ Aplica√ß√£o de puni√ß√£o
        if user_data["infra√ß√µes"] >= 10:
            await ban_user(message.author, message.channel)
        else:
            punishment_time = punishment_times.get(user_data["infra√ß√µes"], 240)
            if punishment_time == "BAN":
                await ban_user(message.author, message.channel)
            else:
                await apply_timeout(message.author, message.channel, punishment_time)

    else:
        await bot.process_commands(message)

async def apply_timeout(user, channel, duration):
    try:
        await user.timeout(
            datetime.now(timezone.utc) + timedelta(minutes=duration),
            reason=f"Uso de palavras proibidas - Puni√ß√£o de {duration} minutos")
        await send_countdown_popup(user, channel, duration)
    except discord.Forbidden:
        await channel.send(f"üö® **Erro:** O bot n√£o tem permiss√£o para punir {user.mention}.")
    except Exception as e:
        await channel.send(f"üö® **Erro ao aplicar puni√ß√£o para {user.mention}:** {e}")

async def send_countdown_popup(user, channel, duration):
    """ Envia um popup com contador regressivo enquanto o usu√°rio estiver silenciado """
    embed = discord.Embed(
        title="‚è≥ Voc√™ est√° punido!",
        description=f"Voc√™ est√° bloqueado por **{duration} minutos**. Aguarde o tempo expirar.",
        color=discord.Color.red()
    )
    message = await channel.send(f"{user.mention}", embed=embed)

    remaining_time = duration * 60  # Convertendo minutos para segundos
    while remaining_time > 0:
        if remaining_time > 60:
            display_time = f"{remaining_time // 60} minutos"
        else:
            display_time = f"{remaining_time} segundos"

        embed.description = f"‚è≥ **Tempo restante:** {display_time}"
        await message.edit(embed=embed)
        
        await asyncio.sleep(2)  # Atualiza o tempo a cada 10 segundos
        remaining_time -= 2

    embed.title = "‚úÖ Puni√ß√£o encerrada!"
    embed.description = "Agora voc√™ pode enviar mensagens novamente."
    embed.color = discord.Color.green()
    await message.edit(embed=embed)

async def ban_user(user, channel):
    """ Bane o usu√°rio se atingir 10 infra√ß√µes """
    try:
        await user.ban(reason="Atingiu 10 infra√ß√µes de mensagens proibidas.")
        await channel.send(f"üö® {user.mention} foi **banido permanentemente** por atingir 10 infra√ß√µes.")
    except discord.Forbidden:
        await channel.send(f"üö® **Erro:** O bot n√£o tem permiss√£o para banir {user.mention}.")
    except Exception as e:
        await channel.send(f"üö® **Erro ao banir {user.mention}:** {e}")

async def exibir_infracoes_do_usuario(message):
    # Tentar apagar o comando enviado
    try:
        await message.delete()
    except discord.Forbidden:
        pass  # Sem permiss√£o para apagar a mensagem

    # Verificar se o autor √© administrador
    if not message.author.guild_permissions.administrator:
        await message.channel.send(f"{message.author.mention}, voc√™ n√£o tem permiss√£o para usar este comando.")
        return

    # Separar o comando e argumentos
    args = message.content.split()
    if len(args) < 2:
        await message.channel.send(f"{message.author.mention}, use o comando assim: `!infracoes <ID ou nome do usu√°rio>`")
        return

    usuario_argumento = " ".join(args[1:]).strip().lower()

    try:
        with open("infractions.json", encoding="utf-8") as f:
            infractions = json.load(f)
    except FileNotFoundError:
        await message.channel.send(f"{message.author.mention}, nenhum registro de infra√ß√£o foi encontrado.")
        return

    guild_id = str(message.guild.id)

    if guild_id not in infractions:
        await message.channel.send(f"{message.author.mention}, este servidor n√£o possui dados de infra√ß√µes.")
        return

    # Procurar usu√°rio por ID ou nome
    user_data = None
    user_id_encontrado = None

    for uid, data in infractions[guild_id]["users"].items():
        if usuario_argumento == uid or usuario_argumento == data.get("nome_usuario", "").lower():
            user_data = data
            user_id_encontrado = uid
            break

    if not user_data:
        await message.channel.send(f"{message.author.mention}, usu√°rio n√£o encontrado nas infra√ß√µes.")
        return

    registros = user_data.get("registros", [])
    if not registros:
        await message.channel.send(f"{message.author.mention}, o usu√°rio n√£o possui infra√ß√µes detalhadas registradas.")
        return

    # Criar o texto com as infra√ß√µes
    texto = f"**üë§ Usu√°rio:** {user_data.get('nome_usuario', 'Desconhecido')} (ID: {user_id_encontrado})\n"
    texto += f"**üî¢ Infra√ß√µes:** {user_data.get('infra√ß√µes', 0)} | **üö´ Puni√ß√µes:** {user_data.get('puni√ß√µes', 0)}\n\n"

    for i, registro in enumerate(registros, 1):
        texto += f"**{i}.** `{registro['data']}` no canal **#{registro['canal']}**\n"
        texto += f"üó®Ô∏è _\"{registro['mensagem']}\"_\n\n"

    try:
        await message.author.send("üì¨ Aqui est√£o as infra√ß√µes do usu√°rio solicitado:")
        await message.author.send(texto)
        await message.channel.send(f"{message.author.mention}, as infra√ß√µes foram enviadas no seu privado. üì•")
    except discord.Forbidden:
        await message.channel.send(f"{message.author.mention}, n√£o consegui te enviar uma DM. Verifique se voc√™ permite mensagens diretas do servidor.")

# Tratamento de erros de comando
@bot.event
async def on_command_error(ctx, error):
    print(f"Erro ao executar comando: {error}")

# Comando GPT personalizado
@bot.command()
async def gpt(ctx, *, prompt: str):
    try:
        from openai import AsyncOpenAI
        client = AsyncOpenAI()
        response = await client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system",
                    "content": (
                        "Voc√™ √© um assistente amig√°vel que responde em portugu√™s de forma clara e objetiva."
                    )
                },
                {"role": "user", "content": prompt}
            ],
            max_tokens=300,
            temperature=0.7
        )
        resposta = response.choices[0].message.content.strip()
        await ctx.send(resposta)
        try:
            await ctx.author.send(resposta)
        except discord.Forbidden:
            print(f"N√£o foi poss√≠vel enviar DM para {ctx.author}.")
    except Exception as e:
        print("Erro ao consultar a API da OpenAI:", e)
        await ctx.send("Houve um erro ao consultar o GPT.")

# Inicia o bot
bot.run(token)